// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sonic_gnoi.proto

package gnoi_sonic

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SonicOutput struct {
	Status               int32    `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	StatusDetail         string   `protobuf:"bytes,2,opt,name=status_detail,json=statusDetail,proto3" json:"status-detail" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SonicOutput) Reset()         { *m = SonicOutput{} }
func (m *SonicOutput) String() string { return proto.CompactTextString(m) }
func (*SonicOutput) ProtoMessage()    {}
func (*SonicOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{0}
}
func (m *SonicOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SonicOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SonicOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SonicOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SonicOutput.Merge(m, src)
}
func (m *SonicOutput) XXX_Size() int {
	return m.Size()
}
func (m *SonicOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SonicOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SonicOutput proto.InternalMessageInfo

func (m *SonicOutput) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SonicOutput) GetStatusDetail() string {
	if m != nil {
		return m.StatusDetail
	}
	return ""
}

type TechsupportRequest struct {
	Input                *TechsupportRequest_Input `protobuf:"bytes,1,opt,name=input,proto3" json:"sonic-show-techsupport:input" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TechsupportRequest) Reset()         { *m = TechsupportRequest{} }
func (m *TechsupportRequest) String() string { return proto.CompactTextString(m) }
func (*TechsupportRequest) ProtoMessage()    {}
func (*TechsupportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{1}
}
func (m *TechsupportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechsupportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechsupportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechsupportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechsupportRequest.Merge(m, src)
}
func (m *TechsupportRequest) XXX_Size() int {
	return m.Size()
}
func (m *TechsupportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TechsupportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TechsupportRequest proto.InternalMessageInfo

func (m *TechsupportRequest) GetInput() *TechsupportRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

type TechsupportRequest_Input struct {
	Date                 string   `protobuf:"bytes,1,opt,name=date,proto3" json:"date,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TechsupportRequest_Input) Reset()         { *m = TechsupportRequest_Input{} }
func (m *TechsupportRequest_Input) String() string { return proto.CompactTextString(m) }
func (*TechsupportRequest_Input) ProtoMessage()    {}
func (*TechsupportRequest_Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{1, 0}
}
func (m *TechsupportRequest_Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechsupportRequest_Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechsupportRequest_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechsupportRequest_Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechsupportRequest_Input.Merge(m, src)
}
func (m *TechsupportRequest_Input) XXX_Size() int {
	return m.Size()
}
func (m *TechsupportRequest_Input) XXX_DiscardUnknown() {
	xxx_messageInfo_TechsupportRequest_Input.DiscardUnknown(m)
}

var xxx_messageInfo_TechsupportRequest_Input proto.InternalMessageInfo

func (m *TechsupportRequest_Input) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

type TechsupportResponse struct {
	Output               *TechsupportResponse_Output `protobuf:"bytes,1,opt,name=output,proto3" json:"sonic-show-techsupport:output" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TechsupportResponse) Reset()         { *m = TechsupportResponse{} }
func (m *TechsupportResponse) String() string { return proto.CompactTextString(m) }
func (*TechsupportResponse) ProtoMessage()    {}
func (*TechsupportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{2}
}
func (m *TechsupportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechsupportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechsupportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechsupportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechsupportResponse.Merge(m, src)
}
func (m *TechsupportResponse) XXX_Size() int {
	return m.Size()
}
func (m *TechsupportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TechsupportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TechsupportResponse proto.InternalMessageInfo

func (m *TechsupportResponse) GetOutput() *TechsupportResponse_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

type TechsupportResponse_Output struct {
	OutputFilename       string   `protobuf:"bytes,1,opt,name=output_filename,json=outputFilename,proto3" json:"output-filename" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TechsupportResponse_Output) Reset()         { *m = TechsupportResponse_Output{} }
func (m *TechsupportResponse_Output) String() string { return proto.CompactTextString(m) }
func (*TechsupportResponse_Output) ProtoMessage()    {}
func (*TechsupportResponse_Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{2, 0}
}
func (m *TechsupportResponse_Output) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TechsupportResponse_Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TechsupportResponse_Output.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TechsupportResponse_Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TechsupportResponse_Output.Merge(m, src)
}
func (m *TechsupportResponse_Output) XXX_Size() int {
	return m.Size()
}
func (m *TechsupportResponse_Output) XXX_DiscardUnknown() {
	xxx_messageInfo_TechsupportResponse_Output.DiscardUnknown(m)
}

var xxx_messageInfo_TechsupportResponse_Output proto.InternalMessageInfo

func (m *TechsupportResponse_Output) GetOutputFilename() string {
	if m != nil {
		return m.OutputFilename
	}
	return ""
}

type CopyConfigRequest struct {
	Input                *CopyConfigRequest_Input `protobuf:"bytes,1,opt,name=input,proto3" json:"sonic-config-mgmt:input" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CopyConfigRequest) Reset()         { *m = CopyConfigRequest{} }
func (m *CopyConfigRequest) String() string { return proto.CompactTextString(m) }
func (*CopyConfigRequest) ProtoMessage()    {}
func (*CopyConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{3}
}
func (m *CopyConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyConfigRequest.Merge(m, src)
}
func (m *CopyConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *CopyConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CopyConfigRequest proto.InternalMessageInfo

func (m *CopyConfigRequest) GetInput() *CopyConfigRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

type CopyConfigRequest_Input struct {
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Overwrite            bool     `protobuf:"varint,2,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	Destination          string   `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyConfigRequest_Input) Reset()         { *m = CopyConfigRequest_Input{} }
func (m *CopyConfigRequest_Input) String() string { return proto.CompactTextString(m) }
func (*CopyConfigRequest_Input) ProtoMessage()    {}
func (*CopyConfigRequest_Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{3, 0}
}
func (m *CopyConfigRequest_Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyConfigRequest_Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyConfigRequest_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyConfigRequest_Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyConfigRequest_Input.Merge(m, src)
}
func (m *CopyConfigRequest_Input) XXX_Size() int {
	return m.Size()
}
func (m *CopyConfigRequest_Input) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyConfigRequest_Input.DiscardUnknown(m)
}

var xxx_messageInfo_CopyConfigRequest_Input proto.InternalMessageInfo

func (m *CopyConfigRequest_Input) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *CopyConfigRequest_Input) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *CopyConfigRequest_Input) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type CopyConfigResponse struct {
	Output               *SonicOutput `protobuf:"bytes,1,opt,name=output,proto3" json:"sonic-config-mgmt:output" xml:",comment"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CopyConfigResponse) Reset()         { *m = CopyConfigResponse{} }
func (m *CopyConfigResponse) String() string { return proto.CompactTextString(m) }
func (*CopyConfigResponse) ProtoMessage()    {}
func (*CopyConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_75b35b752d70e98f, []int{4}
}
func (m *CopyConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyConfigResponse.Merge(m, src)
}
func (m *CopyConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *CopyConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CopyConfigResponse proto.InternalMessageInfo

func (m *CopyConfigResponse) GetOutput() *SonicOutput {
	if m != nil {
		return m.Output
	}
	return nil
}

func init() {
	proto.RegisterType((*SonicOutput)(nil), "gnoi.sonic.SonicOutput")
	proto.RegisterType((*TechsupportRequest)(nil), "gnoi.sonic.TechsupportRequest")
	proto.RegisterType((*TechsupportRequest_Input)(nil), "gnoi.sonic.TechsupportRequest.Input")
	proto.RegisterType((*TechsupportResponse)(nil), "gnoi.sonic.TechsupportResponse")
	proto.RegisterType((*TechsupportResponse_Output)(nil), "gnoi.sonic.TechsupportResponse.Output")
	proto.RegisterType((*CopyConfigRequest)(nil), "gnoi.sonic.CopyConfigRequest")
	proto.RegisterType((*CopyConfigRequest_Input)(nil), "gnoi.sonic.CopyConfigRequest.Input")
	proto.RegisterType((*CopyConfigResponse)(nil), "gnoi.sonic.CopyConfigResponse")
}

func init() { proto.RegisterFile("sonic_gnoi.proto", fileDescriptor_75b35b752d70e98f) }

var fileDescriptor_75b35b752d70e98f = []byte{
	// 522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xee, 0x02, 0x89, 0xc8, 0xa4, 0xb4, 0x65, 0x91, 0x68, 0x14, 0x5a, 0x3b, 0x72, 0x01, 0xf5,
	0x80, 0x5d, 0x29, 0xbd, 0xf5, 0xe8, 0x22, 0x04, 0x07, 0x40, 0x4a, 0x7a, 0xe0, 0x16, 0x25, 0xce,
	0xc6, 0x59, 0x29, 0xde, 0x35, 0xde, 0xdd, 0x06, 0xde, 0x84, 0x2b, 0xcf, 0xc0, 0x4b, 0x70, 0xe4,
	0x09, 0x2c, 0x14, 0x38, 0xf9, 0xc8, 0x13, 0xa0, 0xec, 0x6e, 0x14, 0xb7, 0x49, 0x9a, 0xdb, 0xfc,
	0x7c, 0x33, 0xf3, 0xcd, 0x7e, 0x63, 0xc3, 0x81, 0xe0, 0x8c, 0x46, 0xbd, 0x98, 0x71, 0x1a, 0xa4,
	0x19, 0x97, 0x1c, 0x83, 0xb6, 0x75, 0xb8, 0xe9, 0xc7, 0x54, 0x8e, 0xd5, 0x20, 0x88, 0x78, 0x72,
	0x16, 0xf3, 0x98, 0x9f, 0x69, 0xc8, 0x40, 0x8d, 0xb4, 0xa7, 0x1d, 0x6d, 0x99, 0x52, 0x8f, 0x43,
	0xbd, 0x3b, 0xaf, 0xfb, 0xa8, 0x64, 0xaa, 0x24, 0x7e, 0x0a, 0x55, 0x21, 0xfb, 0x52, 0x89, 0x06,
	0x6a, 0xa1, 0xd3, 0x4a, 0xc7, 0x7a, 0xf8, 0x2d, 0x3c, 0x32, 0x56, 0x6f, 0x48, 0x64, 0x9f, 0x4e,
	0x1a, 0xf7, 0x5a, 0xe8, 0xb4, 0x16, 0x9e, 0x14, 0xb9, 0x6b, 0x13, 0xbe, 0x49, 0xfc, 0xcb, 0xdd,
	0xbd, 0x2f, 0xc9, 0xe4, 0xc2, 0x7b, 0x15, 0xf1, 0x24, 0x21, 0x4c, 0x7a, 0x9d, 0x5d, 0x03, 0x78,
	0xad, 0xf3, 0xde, 0x77, 0x04, 0xf8, 0x8a, 0x44, 0x63, 0xa1, 0xd2, 0x94, 0x67, 0xb2, 0x43, 0x3e,
	0x2b, 0x22, 0x24, 0x66, 0x50, 0xa1, 0x2c, 0x55, 0x52, 0xcf, 0xad, 0xb7, 0x9f, 0x07, 0xcb, 0x95,
	0x82, 0x55, 0x78, 0xf0, 0x6e, 0x8e, 0x0d, 0xdb, 0x45, 0xee, 0x1e, 0x69, 0x8c, 0x2f, 0xc6, 0x7c,
	0xea, 0xcb, 0x25, 0xf0, 0x42, 0x77, 0x5b, 0xc3, 0xc6, 0x8c, 0x69, 0x3e, 0x83, 0x8a, 0xee, 0x81,
	0x31, 0x3c, 0x18, 0xf6, 0x25, 0xd1, 0x73, 0x6b, 0x1d, 0x6d, 0x7b, 0x7f, 0x11, 0x3c, 0xb9, 0x31,
	0x54, 0xa4, 0x9c, 0x09, 0x82, 0x05, 0x54, 0xb9, 0x7e, 0x27, 0xcb, 0xf2, 0xe5, 0x46, 0x96, 0xa6,
	0x20, 0x30, 0xaf, 0x1a, 0x9e, 0x17, 0xb9, 0x7b, 0xbc, 0x81, 0xa7, 0x69, 0xb8, 0x86, 0xa8, 0x1d,
	0xd5, 0xfc, 0x04, 0x55, 0x2b, 0xce, 0x07, 0xd8, 0x37, 0xb1, 0xde, 0x88, 0x4e, 0x08, 0xeb, 0x27,
	0x96, 0x75, 0xf8, 0xa2, 0xc8, 0x5d, 0x9b, 0xf2, 0x17, 0xa9, 0x35, 0x1d, 0xf7, 0x0c, 0xe4, 0x8d,
	0x45, 0x78, 0x39, 0x82, 0xc7, 0x97, 0x3c, 0xfd, 0x7a, 0xc9, 0xd9, 0x88, 0xc6, 0x0b, 0x25, 0xc6,
	0x37, 0x95, 0x38, 0x29, 0xef, 0xb8, 0x82, 0xb6, 0x42, 0xf8, 0x45, 0xee, 0x1e, 0x9a, 0x05, 0x23,
	0x9d, 0xf6, 0x93, 0x38, 0xd9, 0xaa, 0x41, 0x6f, 0xa1, 0xc1, 0xfc, 0xea, 0xb8, 0xca, 0xa2, 0x85,
	0x0a, 0xd6, 0xc3, 0x47, 0x50, 0xe3, 0xd7, 0x24, 0x9b, 0x66, 0x54, 0x12, 0x7d, 0x71, 0x0f, 0x3b,
	0xcb, 0x00, 0x6e, 0x41, 0x7d, 0x48, 0x84, 0xa4, 0xac, 0x2f, 0x29, 0x67, 0x8d, 0xfb, 0xba, 0xb4,
	0x1c, 0xf2, 0x14, 0xe0, 0x32, 0x63, 0xab, 0x62, 0xef, 0x96, 0x8a, 0x87, 0xe5, 0x0d, 0x4b, 0x1f,
	0x43, 0x18, 0x14, 0xb9, 0xdb, 0x58, 0xdd, 0x6a, 0x9b, 0x62, 0xed, 0x1f, 0x08, 0x76, 0x75, 0x9f,
	0x2e, 0xc9, 0xae, 0x69, 0x44, 0xf0, 0x15, 0xec, 0x77, 0xc7, 0x7c, 0x5a, 0xba, 0x10, 0xec, 0xdc,
	0x7d, 0xe0, 0x4d, 0x77, 0xcb, 0x69, 0x79, 0x3b, 0xf8, 0x3d, 0xc0, 0x72, 0x3b, 0x7c, 0x7c, 0xa7,
	0x4e, 0x4d, 0x67, 0x53, 0x7a, 0xd1, 0x2e, 0x3c, 0xf8, 0x39, 0x73, 0xd0, 0xaf, 0x99, 0x83, 0x7e,
	0xcf, 0x1c, 0xf4, 0xed, 0x8f, 0xb3, 0x33, 0xa8, 0xea, 0x5f, 0xc4, 0xf9, 0xff, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x75, 0xf3, 0xdc, 0xf4, 0x71, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SonicServiceClient is the client API for SonicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SonicServiceClient interface {
	ShowTechsupport(ctx context.Context, in *TechsupportRequest, opts ...grpc.CallOption) (*TechsupportResponse, error)
	CopyConfig(ctx context.Context, in *CopyConfigRequest, opts ...grpc.CallOption) (*CopyConfigResponse, error)
}

type sonicServiceClient struct {
	cc *grpc.ClientConn
}

func NewSonicServiceClient(cc *grpc.ClientConn) SonicServiceClient {
	return &sonicServiceClient{cc}
}

func (c *sonicServiceClient) ShowTechsupport(ctx context.Context, in *TechsupportRequest, opts ...grpc.CallOption) (*TechsupportResponse, error) {
	out := new(TechsupportResponse)
	err := c.cc.Invoke(ctx, "/gnoi.sonic.SonicService/ShowTechsupport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sonicServiceClient) CopyConfig(ctx context.Context, in *CopyConfigRequest, opts ...grpc.CallOption) (*CopyConfigResponse, error) {
	out := new(CopyConfigResponse)
	err := c.cc.Invoke(ctx, "/gnoi.sonic.SonicService/CopyConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SonicServiceServer is the server API for SonicService service.
type SonicServiceServer interface {
	ShowTechsupport(context.Context, *TechsupportRequest) (*TechsupportResponse, error)
	CopyConfig(context.Context, *CopyConfigRequest) (*CopyConfigResponse, error)
}

// UnimplementedSonicServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSonicServiceServer struct {
}

func (*UnimplementedSonicServiceServer) ShowTechsupport(ctx context.Context, req *TechsupportRequest) (*TechsupportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowTechsupport not implemented")
}
func (*UnimplementedSonicServiceServer) CopyConfig(ctx context.Context, req *CopyConfigRequest) (*CopyConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyConfig not implemented")
}

func RegisterSonicServiceServer(s *grpc.Server, srv SonicServiceServer) {
	s.RegisterService(&_SonicService_serviceDesc, srv)
}

func _SonicService_ShowTechsupport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechsupportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SonicServiceServer).ShowTechsupport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.sonic.SonicService/ShowTechsupport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SonicServiceServer).ShowTechsupport(ctx, req.(*TechsupportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SonicService_CopyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SonicServiceServer).CopyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.sonic.SonicService/CopyConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SonicServiceServer).CopyConfig(ctx, req.(*CopyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SonicService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.sonic.SonicService",
	HandlerType: (*SonicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShowTechsupport",
			Handler:    _SonicService_ShowTechsupport_Handler,
		},
		{
			MethodName: "CopyConfig",
			Handler:    _SonicService_CopyConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sonic_gnoi.proto",
}

func (m *SonicOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SonicOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SonicOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatusDetail) > 0 {
		i -= len(m.StatusDetail)
		copy(dAtA[i:], m.StatusDetail)
		i = encodeVarintSonicGnoi(dAtA, i, uint64(len(m.StatusDetail)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintSonicGnoi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TechsupportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechsupportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechsupportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSonicGnoi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechsupportRequest_Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechsupportRequest_Input) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechsupportRequest_Input) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintSonicGnoi(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechsupportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechsupportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechsupportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSonicGnoi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TechsupportResponse_Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechsupportResponse_Output) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TechsupportResponse_Output) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OutputFilename) > 0 {
		i -= len(m.OutputFilename)
		copy(dAtA[i:], m.OutputFilename)
		i = encodeVarintSonicGnoi(dAtA, i, uint64(len(m.OutputFilename)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CopyConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSonicGnoi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CopyConfigRequest_Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyConfigRequest_Input) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyConfigRequest_Input) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintSonicGnoi(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintSonicGnoi(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CopyConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSonicGnoi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSonicGnoi(dAtA []byte, offset int, v uint64) int {
	offset -= sovSonicGnoi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SonicOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovSonicGnoi(uint64(m.Status))
	}
	l = len(m.StatusDetail)
	if l > 0 {
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechsupportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechsupportRequest_Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechsupportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TechsupportResponse_Output) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OutputFilename)
	if l > 0 {
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyConfigRequest_Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.Overwrite {
		n += 2
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovSonicGnoi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSonicGnoi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSonicGnoi(x uint64) (n int) {
	return sovSonicGnoi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SonicOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SonicOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SonicOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDetail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDetail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechsupportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechsupportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechsupportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &TechsupportRequest_Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechsupportRequest_Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechsupportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechsupportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechsupportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &TechsupportResponse_Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechsupportResponse_Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFilename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputFilename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &CopyConfigRequest_Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyConfigRequest_Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &SonicOutput{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSonicGnoi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSonicGnoi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSonicGnoi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSonicGnoi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSonicGnoi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSonicGnoi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSonicGnoi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSonicGnoi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSonicGnoi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSonicGnoi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSonicGnoi = fmt.Errorf("proto: unexpected end of group")
)
